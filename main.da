import sys
import random
import time
import q2
import origq2
codePaths=[q2]

class PerfEval(process):
    def setup(p,a,l,n,r,d,w,tp,tl):  # s is set of all other processes
        self.np=p
        self.na=a
        self.nl=l
        self.n=n
        self.r=r
        self.d=d
        self.w=w
        self.tp=tp
        self.tl=tl


    def performanceTesting():
        codes = {}
        for codePath in codePaths:
            output("**********************",codePath,"***********************")
            l = []
            p = []
            a = []
            codes[codePath] = {"l" : l, "p": p, "a" : a}

            for run in range(n):
                output("==============================run:", run, "==================================")

                acceptors = new(codePath.Acceptor, num= na)
                #a.append(acceptors)
                codes[codePath]["a"] = acceptors

                proposers = new(codePath.Proposer, (codes[codePath]["a"],tp,w,r,d), num= np)
                #p.append(proposers)
                codes[codePath]["p"] = proposers

                learners = new(codePath.Learner, (codes[codePath]["a"],tl,r,d), num= nl)
                #l.append(learners)
                codes[codePath]["l"] = learners

                output(codes)

                for pp in codes[codePath]["a"]: setup(pp, (codes[codePath]["l"],r,d))

                #start(a[run] | p[run] | l[run])
                start(codes[codePath]["a"] | codes[codePath]["p"] | codes[codePath]["l"])
                
                #await(each(ll in l[run], has=received(('learning_done', ll), from_=ll)))
                await(each(ll in codes[codePath]["l"], has=received(('learning_done', ll), from_=ll)))

                output("########################Received from learners########################")

                send(('ExecDone',), to= (codes[codePath]["a"]|codes[codePath]["p"]))
                output("$$$$$$$$Send ExecDone to AnP $$$$$$$$$$$ FOR RUN", run)

    def run():
        performanceTesting()
        output("In child", self)
        output('terminating...')
        send(('done', self), to= parent())
        output("Sending done to parent")
        await(received(('done'), from_=parent()))
        output("Awaiting done from parent")
        output("Received done from parent")

def main():
    # p - number of proposers
    p = int(sys.argv[1]) if len(sys.argv) > 3 else 5

    # a - number of acceptors
    a = int(sys.argv[2]) if len(sys.argv) > 3 else 5

    # l - number of learners
    l = int(sys.argv[3]) if len(sys.argv) > 3 else 5

    # n - number of repetitions for each run
    n = int(sys.argv[4]) if len(sys.argv) > 0 else 10

    # r - message loss rate
    r = float(sys.argv[5]) if len(sys.argv) > 1 else 0

    # d - message delay, up to the number of seconds specified
    d = int(sys.argv[6]) if len(sys.argv) > 1 else 0

    # w - wait time, in seconds, before trying a new round
    w = int(sys.argv[7]) if len(sys.argv) > 1 else 0

    # tp - timeout for poposers
    tp = int(sys.argv[8]) if len(sys.argv) > 1 else 2

    # tl - timeout for learners
    tl = int(sys.argv[9]) if len(sys.argv) > 1 else 2

    eval = new(PerfEval, num=1)
    setup(eval,(p,a,l,n,r,d,w,tp,tl))

    output("============", n)

    start(eval)

    await(each(e in eval, has=received(('done', e))))
    
    send(('done'), to=eval)
    output("Sending done to child")

